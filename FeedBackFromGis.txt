Здравствуйте!

Пофиксиные пункты:


	// исправил
+   В режиме распечатки дерева в консоль Tree::PrintTree() вызывается дважды.

	// порпавил
+   Для случая, когда задан только входной файл, пользовательское сообщение не соответствует ситуации (скопировано и не поправлено). 

	// Зделал возвращаемый тип size_t
+  Функция Parser::CountNodes() почему-то возвращает знаковый тип (ещё и int вместо size_t), но, "к счастью", не используется.


Придирки по моему мнению:

	// для тестового задания пойдёт
--- std::string::find(), используемые в функциях Parser, начинают поиск всегда с начала строки, хотя часто можно передать более далёкое стартовое смещение.

	// не было цели более подробно проверять
-   Совпадение количества открывающих и закрывающих скобок не является достаточным условием корректности их расстановки.

	// для тестового задания пойдёт
-   Чтение содержимого файла целиком одним вызовом std::getline() ломается при наличии перегонов строк.

	// мелочи
--- Формат командной строки не соответствует ТЗ; зачем-то реализован интерактивный режим, но нет возможности работать без пользовательского ввода.

	// для тестового задания не важно вроде
--  Parser в случае любой пойманной ошибки возвращает пустые строки, суть ошибки восстановить невозможно. Tree не проверяет результаты работы Parser и создаёт узлы, как получится.

Фидбэк по вашему заданию:

 

--  using namespace std в заголовочных файлах затягивается в клиентский код.

-   void вместо пустого списка аргументов функций -- C-стиль.

--  Константность функций не используется.

--- Тэги для типов определены в узле, дереве и парсере как нестатические, поэтому лежат мёртвым грузом в каждом экземпляре.

--  Поле Node::pParent не используется, функция для его установки тоже не используется.

--  Аргумент pParent конструктора Node не используется, тела двух перегрузок конструктора идентичны.

-   std::stoi(), используемая в конструкторе Node, может кидаться исключениями, которые не ловятся. Если это ожидаемое поведение, то случай с float-данными асимметричен, т.к. вызывается функция atof(), не кидающаяся исключениями.

--  Функция Node::getTag() возвращает строковый тег типа узла по значению.

-   Функция Node::ConvertTagToDataType() реализована, но не используется.

--- Вручную выделенная динамическая память не освобождается вообще нигде.

--  Tree не имеет функций-обёрток для передачи корня в рекурсивные алгоритмы, пользователь вынужден делать это вручную (за исключением функции PrintTree(), тело которой можно реализовать в одну строчку без создания локальной переменной для возвращаемого значения).

--- Строки в функции Tree передаются по значению, даже в рекурсивные.

--- Добавление нового типа узла чрезвычайно затруднено: нужно поправить большое количество мест в коде. Кроме того, тэги для типов определяются дважды -- в узле и в дереве, что усугубляет обозначенную проблему.

--  При обходах дерева циклы используют счётчик типа unsigned int, а не size_t.

-   Лишние включения <windows.h> и <typeinfo> в main.cpp.

--  Сериализация использует промежуточные строки вместо конкатенации в единую строку, что приводит к лишним выделениям памяти.

--  Все алгоритмы обхода рекурсивные.

// здесь остановился

--  indent для потомков в Tree::TreeTraversal() каждый раз формируется заново, хотя значения друг от друга не отличаются, это несколько девальвирует идею предварительной проверки наличия потомков до выполнения их обхода с целью сэкономить на операциях с indent'ом.

--- Вектор потомков возвращается из Node::getSubNodes() по значению, что приводит к лишнему расходу памяти при сериализации и распечатке.

--  Класс Parser хранит поле parseStr, которое инициализируется в конструкторе, но не используется -- все методы класса принимают на вход строку, с которой и работают.

--  Функция Parser::CheckParseString() может возвращать false сразу при обнаружении первой же ошибки, но вместо этого зря продолжает проверять все случаи.
--  Получение подстроки из одного элемента посредством std::string::substr() в Parser::CheckParseString(), а затем строковое сравнение с одной из квадратных скобок -- расточительство, можно было обойтись сравнением отдельных символов.
-   Предупреждение за signed/unsigned mismatch в этой же функции, счётчик цикла unsigned int вместо size_t.
+   Неактуальный комментарий к этой же функции.



--- Parser::CheckBracketsCount() использует чудовищно расточительное сочетание find()/erase(), но, "к счастью", функция не используется. Примерно та же история и с Parser::getRootsFromString().

--- Многие функции Parser создают себе локальные копии входных строк и делают из них мелкие erase(), что катастрофически увеличивает расход памяти и процессорного времени, особенно в контексте рекурсии.







--  В Tree::Deserialization() делаются последовательные вызовы Parser::getTagFromDataString() и Parser::getValFromDataString() для одной и той же входной строки, которая в итоге перебирается по два раза.

--  Отсутствует единый стиль именования идентификаторов, для отступов используются то пробелы, то табуляции -- даже в пределах одного файла.





--  Десериализация дерева не очищает старое содержимое, а от наличия корня зависит ход всей процедуры (что вкупе с передачей корня вручную ещё и нарушает инкапсуляцию), поэтому повторная десериализация файла в тот же объект дерева (например, в main() такое есть) вызывает разыменование нулевого указателя.



+   Забавное ASCII-лого.

















